# Chapter4 가독성

- 테스트 코드는 읽기 쉬워야 한다.
    - 테스트를 읽은 프로그래머는 코드가 해야할 일을 이해할 수 있어야 한다. 또한, 테스트를 실행한 후에는 코드가 실제로 한 일이 무엇인지 말할 수 있어야 한다.
        - 이 모든건 유지보수성 향상에 기여하기 때문이다.
        - 유지보수성이 좋아야 하는 이유 (객사오 182쪽)
            > "미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다. ... (중략) ... 언젠가는 변경이 발생할 것이며 아직까지는 그것이 무엇인지 모른다는 사실을 겸허하게 받아들인다."

## 가독성을 구리게 만드는 구린 냄새들
### 1. 기본타입 단언
- 단언 시에 의도를 알 수 없는 단어나 숫자를 사용하는 경우 (= 추상화 수준이 너무 낮은 경우)
- 개선 방법 : 추상화 수준을 적절하게 올린다.

### 2. 광역 단언
- 너무 많은 검증 범위로 인하여 무엇을 정확히 검사하려는지 알 수 없는 경우. 사소한 변경도 예상과 다른 결과를 만들게 되어 버린다.
- 개선 방법 : 본질과 관련 없는 세부 내용을 테스트에서 제거한다.
> 테스트가 실패하는 이유는 오직 하나뿐이어야 한다.

### 3. 비트 단언
- 비트 연산자로 인하여 테스트의 의도를 알 수 없는 경우 
- 개선 방법 : 비트연산자를 부울 연산자로 교체한다. (+ 설명글도 달어 주면 좋다.)

### 4. 부차적 상세 정보
- 테스크 코드에 부수적인 정보가 너무 많은 경우
- 개선 방법 :
    1. 핵심이 아닌 설정은 메서드로 추출하라. (private메서드나 setUp메서드로)
    2. 적절한 인자와 서술형 이름을 사용하라.
    3. 한 메서드 안에서는 모두 같은 수준으로 추상화하라.
    
### 5. 다중 인격
> 하나의 테스트는 오직 한가미나 똑바로 검사해야 한다.
- 연관 없이 많은 것을 단언하고 있는 경우 (103쪽 주석에 보면 단언문을 하나만 쓰라는 말이 아니다.)
- 개선 방법 : 각자의 테스트로 분리한다. (분리 단위가 클래스가 될 수 도 있고, 메서드가 될 수도 있다.)

### 6. 쪼개진 논리
- 지나친 분리로 인하여 테스트 코드의 흐름을 파악하기 위해서 흩어진 코드들을 분석해야 하는 경우
- 개선 방법 : (114쪽 하단) 사용하는 테슨트 메서드 안에 함께 두는 방법을 찾아보는 게 바람직하다. 여의치 않다면 같은 클래스 안에라도 넣어두자. 쪼개진 논리를 수용하는 건 최후의 보루여야 하낟.

### 7. 매직 넘버
- 리터럴 쓰지마
- 상수표현 말고도, 메서드로 표현하면 다양한 숫자를 담을 수 있네
```
    roll(pins(10), times(12));

    private int pins(int n) { return n;}
    private int times(int n) { return n;}
``` 

### 8. 셋업 설교
- 셋업에 지나치게 많은 준비작업을 하는 경우
- 개선 방법 : 부차적 상세정보와 같은 방법을 사용한다.
    
### 9. 과잉보호 테스트
- 실패에 대한 강박감에 사로잡혀서 필요하지 않은 경우까지 과잉보호하는 경우
- 개선 방법 : 불필요한 단언문을 지워버리자. 


### 키워드 정리

- 부차적 상세정보의 해결책 2번째의 원문을 보면 "Give things appropriate, descriptive names."라고 하는데, 왜 번역에는 적절한 '인자'라는 표현을 썼는지 모르겠네요. 4.4.3 정리 부분의 두번째 문단 첫줄을 보면 결국은 클래스, 메서드, 필드, 변수의 이름을 서술적으로 쓰라는 말 같네요.
    - A) 동의

- 그래도 잘 이해가 안가는건, 픽스처 객체(string, fixnum)의 이름을 서술형으로 바꾸는 것만으로도 부차적 상세정보 냄새를 해결할 수 있었을 거라 하는데, 어떤 식으로 해결된다는 건지...?
    - 일단 Fixnum이 루비에서만 쓰는 타입이라서 느낌이 잘 안오네요...? 그냥 인티저인가

- 104p 예제 코드 아래 부분 "3.3.11절"은 존재하지 않는다는 소름돋는 사실...
    - A) 소오름..

- 픽스처(fixture)라는 단어에 대한 설명은 따로 언급이 없는거죠? 테스트 클래스의 필드로 옮기고 setUp()에서 초기화하는 객체를 fixture라고 부르는 듯 한데...
    - A) 픽스처에 대한 설명은 119쪽 2번째 문단에 있긴 한데 뭔소린지 잘 모르겠네요

- 같은 수준의 추상화인지 아닌지 확인해보는 명확한 기준이나 척도가 있을까요?? 없다구요?
    - A)

- p.113 남아있는 기본 타입 단언이란, assertEquals("3", eval("puts b")); 부분을 의미?

- P.123 과잉보호 테스트.... 불필요한 단언문은 아무런 가치도 보태주지 않는다..
NPE 예시로 보면 getSummary에서 assertNotNull 추가하면 NPE가 발생할 수 있다는 명세가 되는거 아닌가요?? 한줄 추가하면 좋을거 같은데 아무런 가치도 없다고, 실패하면 임시로 추가해서 보라고 그러시네
    - Gumin's A)

        p.121 하단 꼬리말(18)에서 말하는 '명세'란 assertNotNull 같은 단언문이 아니라, 메서드 시그니처를 뜻하는 것 같습니다. 원문에서는, "인자가 null이어야 하는지 여부가 method's contract의 일부가 되어야 한다"고 되어있거든요.
        다만 그걸 구현할 수 있는 방법은 구체적으로 뭐가 있을까 싶긴 한데, @NotNull 같은걸 붙여주는 것도 한 방법이 아닐까요?

        어쨌든 저자가 말하고 싶은건, assertNotNull를 추가하는건 메서드를 체이닝해서 호출하는 경우에 그나마 장점이 있긴 하지만, 어차피 null 참조를 어디서 했는지 추적하고 싶은 거라면 굳이 JUnit이 아닌 NPE의 스택 추적을 통해서도 가능하다. 괜히 필요도 없는 assertNotNull 깔끔하게 빼버리고, 단 메서드 체이닝한 경우에 꼭 JUnit의 '아름다운' 메시지를 보고 싶으면 중간에 임시로 넣었다가 테스트 끝나면 빼라. 이런 말인 것 같습니다.

    - A) 본질에 집중되지 못하는 전개떄문에 그런거 같습니다.

- 
1. 추상화 수준을 일치 시켜라
2. 한 메서드 안에서는 모두 같은 수준으로 추상화하라
3. 세부정보 추출, 단계마다 서술적인 네이밍, 추상화 수준 유지

    A) 킹상화,.