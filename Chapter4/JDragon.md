# 04 가독성

테스트를 보고 코드가 하는 일을 이해할 수 있어야 한다.

단언문은 코드의 올바른 동작을 규정한다.

테스트 코드는 읽기 쉬워야 하고, 테스트가 무슨 일을 하는지 파악하기 위해 머리를 쥐어 뜯는 일은 없어야 한다


## 4.1 기본 타입 단언

단언문은 가정이나 의도를 명시해야 한다. 또한 코드의 동작을 서술하는 **문장** 이어야 한다.
기본 타입 단언이란 단언하려는 이유나 의도가 의미를 알 수 없는 단어나 숫자에 가려진 상황을 말한다.
(2.3 의 엉뚱한 걸 검사하는 건 좋지 않다)


### 4.1.1 예시

테스트의 이름만 보고 무슨 테스트인지 알기 힘든 예시이며 테스트 내용을 봐도 **무엇을** 테스트 하려는건지 알 수가 없다

### 4.1.2 개선방법

기본 타입 단언의 핵심은 단언 대상의 추상화 수준이 너무 낮다는 점이다

해당 예제에서 문자열 조각이 포함되어 있는지 확인할 때 인덱스나 매직 넘버인 -1을 사용하는 건 개념을 잘못 추상화한 예다.
이러한 것은 테스트 이름에 비해 너무 구체적인 추상화 수준이다.(HOW)

테스트 코드에서 어떤 방식으로 의도를 표현할지 결정할 때, 코드 중복이나 성능보다 가독성과 명료성이 더 중요함을 기억해두자

### 4.1.3 정리

- != 나 == 등의 비교문을 사용하는 단언문을 발견하면 추상화 수준이 적절한지 짚어보자.
- -1,0 등의 매직 넘버도 마찬가지다

상위 개념을 기본타입으로 표현하는 냄새로, 전화번호는 String, 약정기간은 Date 로 표현하는 경우를 떠올려보자.

> (뭐가 문제지????????????)

테스트를 작성할 때는 이들 타입과 표현하려는 개념의 추상화 수준과 같은지 신경써야 한다

## 4.2 광역 단언

광역단언은 검사하려는 동작의 아주 작은 하나까지도 놓치지 않으려는 집착의 산물.
이는 곳 하나만 잘못되어도 실패하게 되고 본래 의도했던 것도 넓은 검증 범위에 묻혀 희석된다.


### 4.2.1 예시

너무 광범위한 범위를 비교하면?? 조그만 변화만 생겨도 테스트가 실패한다. 이건 큰 문제다! 왜냐!?

테스트가 실패한다는건 코드가 의도와 다르게 동작하면 잡아낼 수 있다는 뜻이다.
그래서 우리는 과거에 실패해봤고, 같은 문제가 재발하면 다시 실패하는 테스트가 필요한 것이다

그런데 너무 많은 것을 테스트 하고 그중에 작은? 아주 사소한 한가지 때문에 실패한다면 우리는 어느 곳이 틀렸기 때문에
테스트가 실패한 것인지 찾기위해 **개고생**을 해야한다.

쉽게 실패하고 잘 망가지는 테스트는 테스트 실패 이유가 너무 많을 수 있다.
테스트 실패 이유가 많다는 건 테스트 실패의 이유를 파악하기 위해 세부 내용을 분석해봐야 알 수 있다는 것이다.

> 테스트 실패의 이유는 오직 하나 뿐이어야 한다 --> 단일 책임 원칙(SRP)

SRP : 클래스를 수정해야 하는 이유는 오직 하나뿐이어야 한다


### 4.2.2 개선 방법

본질과 관련 없는 세부 내용을 테스트에서 제거할 것. 우리긔 테스트 코드에는 테스트 목적을 이룰 수 있는 만큼의 정보만
담아두면 된다.  **딱 통과할 정도만!** 을 기억하자

자신과 관련 없는 세부 정보를 숨기고 한 가지 일에만 충실하게 하자.

작은 단위에 충실한 테스트라야 실패했을 때 문제의 근본 원인을 빠르게 찾을 수 있다.

### 4.2.3 정리

광역 단언을 사용하면 테스트의 주된 관심사와 상관없이 사소한 변경에도 테스트가 실패한다.

광역 단언은 테스트의 의도와 핵심을 파악하는데 방해가 된다.

## 4.3 비트 선언

### 4.3.1 예시
비트연산자는 저수준의 방법이다.
해당 챕터의 예제는 "지금 실행되는 플랫폼이 32비트냐 64비트냐" 라는 고수준의 논의를 낯선 저수준의 비트 연산자로 가려놓은 예제다

비트 연산자를 사용하면 빠를 수 도 있다. 하지만 이런 최적화가 우리의 목적이 아니다.
우리의 테스트 코드는 의도한 대로 동작하고, 의도가 이치에 맞는가를 확인해야 한다.

### 4.3.2 개선 방법

이 예제에서의 해결책은 비트 연산자를 부울 연산자로 교체하는 방법을 선택했다.
부울 연산자가 단언문의 의도를 더 확실하게 만들어 줄 것이다.

### 4.3.3 정리

비트 연산자는 성능적으로는 좋은 선택일 수도 있지만 의미 파악을 방해한다.
그러니 비트 연산자는 비트 연산자로 남겨두고? 고수준의 개념은 그에 합당한 고차원적 언어로 표현하자.


## 4.4 부차적 상세정보

읽기 쉬운 코드는 의도와 목적과 의미를 빠르고 정확하게 보여준다

### 4.4.1 예제

테스트 대상의 동작을 검증하기 위해, 같은 타입의 객체를 먼저 몇 개 집어넣고, 확인하는 작업을 반복하고 있다.
의도가 명확하지? 않은 코드다. 수많은 객체와 반복문을 모두 추적하기엔 무리가 있고 기본 타입 단언 냄새도 좀 난다

### 4.4.2 개선 방법

테스트의 핵심 지침
- 핵심이 아닌 설정은 private 메서드나 셋업 메서드로 추출
- 적절한 인자와 서술형 이름 사용
- 한 메서드 안에서는 모두 같은 수준으로 추상화

객세 생성부분 -> 셋업 메서드로 추출
지역변수 -> 테스트 클래스 필드로 옮김
Fixnum 과 String을 구분하는 명확한 이름 사용

### 4.4.3 정리

테스트를 작성할 때마다 테스트가 하려는 일이 진짜 명백한가? 생각해라

> 한 메서드 안에서는 모두 같은 수준으로 추상화 하라.

## 4.5 다중 인격

하나의 테스트는 오직 한 가지만 똑바로 검사해야 한다
(테스트당 단언문 하나만 만들어야 한다  라는게 아니다)

### 4.5.1 예시

너무 다양한 것들을 단언하고 있다.

### 4.5.2 개선 방법

중복을 제거.
두 개의 시나리오가 존재한다. 두개의 서로 다른 테스트가 존재함을 의미하는 것이니 각자의 테스트로 분리한다.

큰 시나리오만 떼어내도 테스트 메서드에 서술적인 이름을 지어주기 수월해진다.

다중 인격(여러개의 영혼(테스트목적)이 한 몸(테스트메서드)을 공유하는 것)
다중 인격을 복수의 독립된 테스트 클래스로 분리한다.

테스트 클래스 각각이 하나의 주제에만 충실해진다.
공유할 건 거의 없고 테서트 메서드와 그에 딸린 픽스처를 분리하는 것으로 충분하다면, 따로 떼어 독립된 클래스로 만드는 것이 좋다.

### 4.5.3 정리

읽기 쉬운 코드는 프로그래머에게 자신의 목적을 명확히 전해준다.
다중인격 코드를 각자의 클래스로 분리하면 테스트 의미가 드러나 이해하기 쉬워진다.
코드를 수정하는 일도 훨씬 수월해진다.
또한 코드가 뭘 하는 것인지, 어떤 시나리오가 빠져 있는지도 쉽게 파악할 수 있다.

> 테스트 클래스나 메서드를 작게 나누면 대개는 가독성과 유지보수성이 좋아진다.




