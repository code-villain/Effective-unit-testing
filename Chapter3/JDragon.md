# 03 테스트 더블

# 3.1 테스트 더블의 위력

어떤 코드가 올바른 동작을 수행하는지 검증하려 할 때, 주변 코드를 모두 교체하여
테스트 환경 전반을 통제할 수 있다면 좋다. 이렇게 **테스트 대상 코드와 협력 객체를 잘 분리** 하면 된다.

테스트 더블을 이용하면 테스트 대상 코드를 주변으로부터 쉽게 떼어낼 수 있다

테스트 더블의 효과
- 테스트 대상 코드를 격리한다
- 테스트 속도를 개선한다
- 예측 불가능한 실행 요소를 제거한다
- 특수한 상황을 시뮬레이션 한다
- 감춰진 정보를 얻어낸다


## 3.1.1 테스트 대상 코드를 격리한다

테스트 대상 코드를 격리한다? 두가지로 나누어 생각한다

- 테스트 대상 코드
- 테스트 대상 코드와 상호작용하는 코드


테스트 대상 객체와 직접적으로 협력하는 객체만 격리시키면 된다. 그 외(간접적으로 협력)의 객체는
격리된 객체들의 모조품을 통해서 만들 수 있다.

## 3.1.2 테스트 속도를 개선한다

테스트 더블을 이용해 사전에 계산해둔 결과를 이용할 수 있다면?
쓸데없이 계산하는 시간을 줄일 수 있다.

## 3.1.3 예측 불가능한 실행 요소를 제거한다

테스트란? 동작을 정의하고 명세와 일치하는지 확인하는 작업
몇번을 반복해서 실행하더라도 항상 같은 결과가 나오도록 해야 한다

단, 시간과 관련된 동작은 본질적으로 비결정적 코드이다

예측할 수 없는 요인을 다뤄야 할 때에도 테스트 더블이 해결책이 될 수 있다
항상 똑같은 시간을 알려주는 테스트 더블로 시스템 시계를 갈아 끼워주면 되지 않을까?

협력 객체를 통해 변수를 제거해서 테스트 하려는 조건과 시나리오를 명확히 하는 근본 이유는
결과에 영향을 주는 모든 요소를 결정적으로 만들기 위해서다.
현실에서 드물게 발생하는 특수한 상황도 테스트 더블로 시뮬레이션 할 수 있다


## 3.1.4 특수한 상황을 시뮬레이션 한다

제품 코드 기능과 API 만으로 만들어내지 못하는 상황도 있을 수 있다.

길찾기 프로그램에서 구글 맵스를 사용한다고 가정해보자.
목적지까지 경로를 요청하는 도중 인터넷이 끊겨버릴때 어떤식으로 대처할 수 있는지 어떻게 확인하냐?

실행 도중에 네트워크 오류를 만들어내는 방법? 테스트 더블을 사용하면 된다
연결 요청을 처리하는 부분을 테스트 더블로 대체해서 예외를 발생시키면 된다

## 3.1.5 감춰진 정보를 얻어낸다

테스트 더블의 존재 이유 중 하나는 테스트가 얻을 수 없었던 정보에 접근하기 위해서다
테스트 더블을 이용해서 테스트 대상 코드와 협력 객체 사이의 상호작용을 확인한다

> 객체 바깥에서 안쪽을 들춰보는 건 잘못된 생각이다. 이것은 추상화를 잘못한 문제다
?????????????????????????????????????

상호작용을 확인하는 방법?
private 필드를 노출하고, 필드의 상태를 알려주는 메서드를 추가하는 방법이 있지만...?
테스트 목적 외에는 쓰일 일 없는 메서드로 제품 코드를 더럽히지 말자.

해결책? 당연히 테스트 더블이다.
필드의 상태를 알려주는 테스트 전용 메서드를 테스트 코드에만 추가하면 된다.

예) 제품코드 : Engine

~~~
public class TestEngine extends Engine {
  ...
  public boolean isRunning() {...}

}
~~~

이러한 테스트 더블을 만들어주면 된다.

# 3.2 테스트 더블의 종류

## 3.2.1 테스트 스텁은 유난히 짧다









