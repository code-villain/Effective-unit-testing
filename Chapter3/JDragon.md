# 03 테스트 더블

# 3.1 테스트 더블의 위력

어떤 코드가 올바른 동작을 수행하는지 검증하려 할 때, 주변 코드를 모두 교체하여
테스트 환경 전반을 통제할 수 있다면 좋다. 이렇게 **테스트 대상 코드와 협력 객체를 잘 분리** 하면 된다.

테스트 더블을 이용하면 테스트 대상 코드를 주변으로부터 쉽게 떼어낼 수 있다

테스트 더블의 효과
- 테스트 대상 코드를 격리한다
- 테스트 속도를 개선한다
- 예측 불가능한 실행 요소를 제거한다
- 특수한 상황을 시뮬레이션 한다
- 감춰진 정보를 얻어낸다


## 3.1.1 테스트 대상 코드를 격리한다

테스트 대상 코드를 격리한다? 두가지로 나누어 생각한다

- 테스트 대상 코드
- 테스트 대상 코드와 상호작용하는 코드


테스트 대상 객체와 직접적으로 협력하는 객체만 격리시키면 된다. 그 외(간접적으로 협력)의 객체는
격리된 객체들의 모조품을 통해서 만들 수 있다.

## 3.1.2 테스트 속도를 개선한다

테스트 더블을 이용해 사전에 계산해둔 결과를 이용할 수 있다면?
쓸데없이 계산하는 시간을 줄일 수 있다.

## 3.1.3 예측 불가능한 실행 요소를 제거한다

테스트란? 동작을 정의하고 명세와 일치하는지 확인하는 작업
몇번을 반복해서 실행하더라도 항상 같은 결과가 나오도록 해야 한다

단, 시간과 관련된 동작은 본질적으로 비결정적 코드이다

예측할 수 없는 요인을 다뤄야 할 때에도 테스트 더블이 해결책이 될 수 있다
항상 똑같은 시간을 알려주는 테스트 더블로 시스템 시계를 갈아 끼워주면 되지 않을까?

협력 객체를 통해 변수를 제거해서 테스트 하려는 조건과 시나리오를 명확히 하는 근본 이유는
결과에 영향을 주는 모든 요소를 결정적으로 만들기 위해서다.
현실에서 드물게 발생하는 특수한 상황도 테스트 더블로 시뮬레이션 할 수 있다


## 3.1.4 특수한 상황을 시뮬레이션 한다

제품 코드 기능과 API 만으로 만들어내지 못하는 상황도 있을 수 있다.

길찾기 프로그램에서 구글 맵스를 사용한다고 가정해보자.
목적지까지 경로를 요청하는 도중 인터넷이 끊겨버릴때 어떤식으로 대처할 수 있는지 어떻게 확인하냐?

실행 도중에 네트워크 오류를 만들어내는 방법? 테스트 더블을 사용하면 된다
연결 요청을 처리하는 부분을 테스트 더블로 대체해서 예외를 발생시키면 된다

## 3.1.5 감춰진 정보를 얻어낸다

테스트 더블의 존재 이유 중 하나는 테스트가 얻을 수 없었던 정보에 접근하기 위해서다
테스트 더블을 이용해서 테스트 대상 코드와 협력 객체 사이의 상호작용을 확인한다

> 객체 바깥에서 안쪽을 들춰보는 건 잘못된 생각이다. 이것은 추상화를 잘못한 문제다
?????????????????????????????????????

상호작용을 확인하는 방법?
private 필드를 노출하고, 필드의 상태를 알려주는 메서드를 추가하는 방법이 있지만...?
테스트 목적 외에는 쓰일 일 없는 메서드로 제품 코드를 더럽히지 말자.

해결책? 당연히 테스트 더블이다.
필드의 상태를 알려주는 테스트 전용 메서드를 테스트 코드에만 추가하면 된다.

예) 제품코드 : Engine

```java
public class TestEngine extends Engine {
  ...
  public boolean isRunning() {...}

}
```

이러한 테스트 더블을 만들어주면 된다.

# 3.2 테스트 더블의 종류

- 스텁
- 페이크
- 스파이
- 목

## 3.2.1 테스트 스텁은 유난히 짧다

스텁의 목적
- 원래의 구현을 최대한 단순한 것으로 대체하는 것 (ex: 기본값을 반환하는 한 줄짜리 메서드)

```java
public class LoggerStub implements Logger {
  public void log() {}
}
```

log() 메서드가 아무일도 하지 않는다?? 이게 스텁이다
로그와 관련 없는 기능을 검사할 때는 로그가 있는지조차 알 필요 없으니까!

```java
public class LoggerStub implements Logger {
  public void log() {}
  public LogLevel getLogLevel() {
    return LogLevel.WARN;
  }
}
```

이건? 하드코딩 해버렸다. 이게 스텁이다

진짜 Logger 가 아닌 스텁을 사용하는 이유?
- 테스트는 대상 코드가 로깅하는 내용에 관심이 없다
- 가동 중인 로그 서버가 없으니 로깅은 어차피 실패했을 거다
- 테스트 스위트가 콘솔로 대량의 정보를 쏟아내는 건 바라지 않는다

Logger 와 같은 타입이면서 특정일만 하거나 아무 일도 하지 않는 것.

그런데 다른 LogLevel을 반환하는게 필요하다? 다른 시나리오에 맞는 스텁을 따로 구현해야한다


만약 최소한의 행동이나 입력값에 따라 다르게 행동하는게 필요하다면? 페이크가 필요하다

## 3.2.2 가짜 객체는 뒤끝 없이 처리한다

진짜객체를 흉내 내지만 진짜 객체를 사용할 때 생기는 부수효과나 연쇄 동작이 일어나지 않도록 경량화하고
최적화한 것이다

대표적인 예로 영속성이 있다.
UserRepostiroy 인터페이스를 구현한 MemoryUserRepository 클래스를 만든다


## 3.2.3 테스트 스파이는 기밀을 훔친다? (잠복경찰?)

```java
public void filter(List list, Predicate predicate) {}
```

위와 같은 메서드는 어떻게 검사할래?
이 기능은 list 와 predicate 를 입력받아 원소를 제거하는 기능이다.
올바로 동작했는지 검사하려면 호출 후에 list 를 검사하는 방법밖에 없다
테스트 스파이를 쓰면 된다

테스트 스파이는 입력 인자로 사용되는 객체가 테스트에 필요한 정보를 알려주는 API 를 제공하지 않을 때 유용하다.

책에 나온 예제는 write 한 메시지가 잘 기록 되어있는지를 확인하는 테스트다
Spy 객체를 만들어 그놈에게서 기능이 정상적으로 잘 작동했는지 확인하는 방법이다

테스트 스파이는 목격한 일을 기록해두었다가 나중에 테스타가 확인할 수 있게끔 만들어진 테스트 더블!

## 3.2.4 Mock 객체는 예기치 않은 일을 막아준다 (원격 조종 사이보그????)

특정 조건이 발생하면 미리 약속된 행동을 취한다
스텁보다 정교한 테스트가 가능하다

테스트 중에 발생할 일과 그 일이 발생했을 때의 행동지침을 입력한다
책의 예제에서는 특정 일이 발생했을 때 특정 문자열을 반환하게 만들었다.
스텁과 비슷하지만 이 동작이 정말로 일어났는지, 몇번 일어났는지를 확인할 수 있다

목은 목 객체 라이브러리를 읽어보자...

# 3.3 테스트 더블 활용 지침

## 3.3.1 용도에 맞는 더블을 선택하라

테스트를 가장 읽기 쉽게 만들어주는 선택을 해라.

지침?

- 두 객체간 상호작용의 결과로 특정 메서드가 호출 되었는지 확인? --> Mock
- Mock 을 쓰려는데 뭔가 복잡해! 단순화 시킨다 --> 스파이
- 협력 객체는 자리만 지키고 협력 객체가 대상 객체에 넘겨줄 응답도 통제가 가능? --> 스텁
- 필요한 서비스나 컴포넌트를 준비하지 못해 스텁을 대용품으로 사용하고 있는데
  뭔가 시나리오가 너무 복잡해. --> 페이크
- 웬만하면 Mock or 스텁. 어쩌다 페이크 사용.  그럼 스파이느....

> 스텁은 질문하고 Mock 은 행동한다. 무슨 질문...?  "이거면 돼? 이거면 충분해?" 이런 질문?


## 3.3.2 준비하고 , 시작하고, 단언하라 (이게 AAA 였나)

맞네. AAA(Arrange-Act-Assert)
협력 객체 준비 , 기능 검사, 기대했던 효과인지 확인

> Given, When, Then
> 주어진 상황에서, 어떤 일 발생, 특정 결과 기대
> 기대하는 행위(동작)를 더 직관적인 언어로 표현하기 위한 노력

만약? 세 영역 중 하나가 비대하다고 느껴지면?? 너무 많은 것을 검사하려는 것 아닐까 의심해라
더 작은 단위의 기능을 집중적으로 검사하는 테스트로 나눌 필요가 있다는 신호다

## 3.3.3 구현이 아니라 동작을 확인하라

테스트와 관련된 모든 것을 Mock 객체로 만들고, 객체간의 사소한 메서드 호출 하나까지 깐깐하게 정의하지 마라

테스트는 무언가 잘못 변경되면 즉시 실패하여 우리에게 알려줘야 한다
그런데? 별 쓰잘데기 없는 변경이 테스트를 실패하게 한다? 이것은 산만한 테스트다

> 테스트는 오직 한가지만 검사해야 하고 그 의도를 명확히 전달하도록 작성 되어야 한다

검사하고자 하는게 뭔가, 부수적인 구현이 뭔가를 확실히 구별해라
부수적인 구현은 호출 횟수에 전혀 개의치 않는 Mock 객체나 스텁으로 충분하다??
> 이거 오타인가???

Mock 객체 라이브러리를 사용할 땐 구현이 아니라 동작을 검증하라.


## 3.3.4 자신의 도구를 선택하라

Mockito - 스텁 사용에 유리하다??

중요한 것은 테스트 코드는 지금이나 앞으로나 읽기 쉽고 간결하고 관하기 쉬워야 한다는 것이다

## 3.3.5 종속 객체를 주입하라

진짜 객체를 다른 것과 교체할 방법이 없다?? 테스트 더블 못쓴다.
종속 객체가 문제인데, 다른 객체로 교체해야만 쉽게 검사할 수 있다면 그 객체를 사용하는 곳과
생성하는 곳을 달리 하는 것이 좋다. 즉 종속 객체를 private 필드에 저장하거나 팩토리 메서드 등을 통해
외부로부터 얻도록 해야한다

종속 객체에 접근하려면 종속 객체를 외부에서 안으로 집어넣는 방법을 사용하라.
보통 생성자 주입 방식을 사용한다

빨리 2부로 넘어가고 싶어 근질근질~

# 3.4 요약

테스트 더블을 알아야 하는 이유?
- 테스트 대상 코드를 격리해야지만 모든 시나리오를 시물레이션하고 모든 동작을 검증할 수 있다
- 예측 불가능한 요소를 예측 가능하게 바꿀 수 있다
- 특수한 상황을 재현할 수 있다
- 테스트 하려면 제품 설계를 바꿔야만 하는 일을 테스트 더블로 막을 수 있다

테스트 더블의 종류
- 스텁 : 불필요한 협력 객체를 없앨 때 (하드코딩)
- 페이크 : 진짜 객체를 대체할게 필요할 때 (영속성)
- 스파이 : 본래 접근할 수 없었던 내부 정보가 궁금할 때 (직접 침투시켜야 하는 놈)
- 목 : 기대한 상호작용이 정말로 일어났는지 확인할 때 (행위 검증)

테스트 더블 활용 지침
- Mock 객체 사용할 때 자잘한 구현은 확인하지 마라
- 의도한 동작이 제대로 일어났는지 검사했다면 Mock 은 역할을 다했다
- 세부 과정은 본질과 거리가 있으니 넘어가자








