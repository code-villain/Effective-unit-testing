# Chapter3 테스트 더블

- 이들 유틸리티(= 스텁, 더미, 더블)가 등장한 가장 큰 이유는 재품 코드가 온전히 준비되기 전까지 사용할 대용품이 필요했기 때문이다. 대용품이 있다면 주변 모듈을 다 갖추지 못했더라도 코드 일부만을 따로 컴파일하고 실행해볼 수 있다.

# 테스트 더블을 사용하는 이유

1. **테스트하려는 코드를 주변에서 분리**하는 것이 테스트 더블을 활용하는 가장 기본적인 이유다.
2. 테스트 속도를 개선한다.
3. 예측 불가능한 실행 요소를 제거한다. (테스트 하고자 하는 행위에 집중할 수 있겠군)
4. 특수한 상황을 시뮬레이션 한다.
5. 감춰진 정보를 얻어낸다.


---

# 키워드 정리

- 자동화 된 테스트를 설계 수단으로 사용하면 테스트 -> 코딩 -> 설계(리팩토링) 순으로 된다 
이거 TDD 아닌가?
    - 그러하다

- 구조화 되있으면 이해하기 좋다
통짜 소스를 도메인 모델이나 개념에 따라 여러조각으로 나누는게 좋다
경계가 모호하면 오히려 안나누는 것만 못하다
    - 근데 실제 프로덕션 프로젝트와 같은 식으로 구조화하는게 국룰아닌가요.? 다른 방식의 구조화 방식은 떠오르지도 않는데

- 구현 보다 동작을 확인하라
테스트 검증에 필요한 최소한만 남기고 부수적인 구현은 검증대상에서 빼라
    - 여기서도 How가 아니라 What의 가치가.. 소오름

- Spy 내용 중에 `SpyTarget`이 `DLogTarget`이라는 진짜 객체를 대체하는 테스트 더블(Spy)인거죠?
    - 네 DLog 라는 객체를 테스트하고 단언하고 싶은데, 이를 위해서 사용하는 테스트 더블입니다.

- p61 그림 3-1 처럼 많은 테스트더블을 사용하면, 실제 객체의 행동이 바뀔때 더블 객체들도 수정해야해서 엄청 힘들것 같아

- p81 종속객체 주입법의 한 가지 예로 di를 생각해도 무리 없겠죠 (ex Autowired)

- 테스트 코드를 우선 작성한 후에 제품 코드로 반영하는 식의 코딩을 하면. 불필요한 코드를 제거할 수 있다. 올바른 설계를 할 수 있다. 실제로 그럴까? 실제로 그렇다
    - 이것이 TDD의 가치

- "p53 순서를 가정하면 안된다 라고 하는데, 제이유닛에서 테스트 순서를 강제하는 옵션을 사용하는 경우는 어떤가요? 문제 없을거같은데"에 대한 답글
↳ 그렇게 되면 "유닛 테스트"라고 볼 수 있을까요? 실행 순서를 설정하는 기능은 통합 테스트에는 어울리겠지만 유닛 테스트로는 나쁜 프랙티스일 것 같아요. 중간에 하나라도 실패하거나 뿩나면 그 다음 테스트 메서드들까지 다 실패인데, 그 순간 유닛 테스트가 아닌거 아닐까 하는 생각이…
    - 동의합니다.

- p78. 세 영역 중 하나가 비대하다고 느껴진다면, 너무 많은 것을 한꺼번에 검사하려는 테스트일 가능성이 높다. 더 작은 단위의 기능을 집중적으로 검사하는 테스트로 나눌 필요가 있다는 신호다.

실제로 이런 경우가 종종 있는데(특히 given이 비대한 경우 多), given(주어진 상황)을 어떻게 작은 테스트로 쪼개지…? 그냥 상황을 깔고 가는 부분인건데… @Test가 아니라 @Before 같은 걸로 해줘야 하는건가
    - 책의 내용을 빌려서 얘기하자면, 비대하다는 건 **너무 많은 것을 한꺼번에 검사하려는 테스트일 가능성이 높다.** 다시 말해 비대하다는건 여러 테스트로 쪼갤 수 있다는 한가지 척도가 될뿐이지. 비대하다가 반드시 쪼개야 한다는 얘기는 아닌거 같습니다. 고민해보고 더 작은 테스트로 만들 수 없다면 그대로 두어도 괜찮다고 생각

- p.33 테스트를 프로그래밍 도구, 즉 설계 도구로 인식하는 순간 품질 고지를 뛰어넘어 설계 고지에 도달하는 길이 열리게 된다.
    - 테스트의 가치와 애플리케이션의 완성도가 얼마나 비례할까.
        - 아는 분 회사는 테스트를 금지시킨 회사도 있었습니다.

- p.46 코드 가독성이 코드 유지보수에 지대한 영향을 끼침을 확인했다. 그렇다면 테스트 코드는 가독성에서 자유로운가? 제품 코드와는 어떻게 다른가?
    - 테스트코드의 유지보수성은 어떤 의미일까. 제품 코드만 수정하고 테스트 코드는 그대로 둬서 에러나면 다들 주석처리 해놓고 작업하다가 한참 뒤에 누군가 수정했던 일이 많았던거 같아서.....
        - 이것이 현실 ㅋㅋ, 이상적인 환경이라면 제품코드가 바뀌면서 테스트 코드도 수정하고 모든 테스트가 돌아가게 하는 것이겠죠.

- P.79 두번째 문단 오타 의심
    - ?

- 3.1.5절에 등장하는 TestEngine(Engine의 구현체; 67p)은 결국 Spy의 일종이네요
    - 그러하네요.