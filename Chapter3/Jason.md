# Effective Unit Testing
## Chapter 3 테스트 더블
> 그러니까 이름이 왜 이따구야?

### 3.1 테스트 더블의 위력
- 주변 코드를 교체함으로써 테스트 환경 전체를 통제할 수 있다.
    - 테스트 대상 코드와 협력 객체를 잘 분리해야한다.
- 테스트 전용 장치가 필요한 이유
    - 테스트 대상 코드를 격리
    - 테스트 속도를 측정
    - 예측 불가능한 실행 요소를 제거
    - 특수상황 시뮬레이션
    - 감춰진 정보 획득

####  3.1.1 테스트 대상 코드 격리
- 테스트 대상 코드를 격리 한다는 것은 테스트 코드를 그외 모든 코드에서 떼어놓는다는 것
    ```
    테스트 대상 코드
    테스트 대상 코드와 상호작용하는 코드
    ```

#### 3.1.2 테스트 속도를 개선
- 협력 객체 사용시 원본을 사용할 때 보다 빨라진다.
- 성능개선은 좋지만 정확성이 떨어진다면 의미 없다.

#### 3.1.3 예측 불가능한 실행 요소 제거
- 시간, 난수와 같이 예측 불가능한 요소를 다뤄야할 경우 예측 가능한 요소로 바꾸면 검증이 쉬워진다.

#### 3.1.4 특수한 상황을 시뮬레이션 한다
- 인터넷이 끊기는 상황을 재연하고 싶을 경우 네트워크 인터페이스를 비활성화 시키는 테스트 더블로 대체하면 된다.

#### 3.1.5 감춰진 정보를 얻어낸다
- 외부에서 접근 할 수 없는 객체가 제대로 동작하는지 확인해야 하는 경우
    - 해당 객체를 테스트 더블로 교체하여 검증 메소드를 추가한다.
    - 실제 코드를 수정할 필요 없이 테스트가 가능해진다.

### 3.2 테스트 더블의 종류
1. 테스트 스텁
    - 원래의 구현을 최대한 단순한 것으로 대체 (아무 일도 하지 않거나, 하드코딩 리턴 등)
    - 테스트 각자의 시나리오에 맞는 스텁을 따로 구현해야 한다.
2. 가짜 객체
    - 원본 객체와 유사하지만 원본을 사용할 때 생기는 부수효과나 연쇄 동작을 제거하여 경량화 한 것
3. 테스트 스파이 객체
    - 구현체에서 내부 로직이 제대로 수행되었는지 확인하기 위한 객체
    - 3.1.4 의 감춰진 정보 확인용인 듯 ???

4. Mock 객체
    - 예기치 않은 일이 발생시 정교한 제어 가능
    - Mockito, JMock 

### 3.3 테스트 더블 활용 지침

#### 3.3.1 용도에 맞게 더블 선택
- 두 객체 간 상호작용의 결과로 특정 메서드가 호출되었는지 확인하고 싶다면 Mock 객처를 써야 할 가능성이 높다.
- Mock 객체를 사용하는데 깔끔히 정리가 안된다면 테스트 스파이를 써서 동일한 결과를 낼 수 있는지 생각해봐라
- 협력 객체는 자리만 지키면 되고 협력 객체가 대상 객체에 넘겨줄 응답도 테스트에서 통제할 수 있다면 스텁이 정답이다.
- 시나리오가 너무 복집해서 테스트 코드가 관리하기 어려울 만큼 복잡해졌다면 가짜 객체를 구현하는 걸 고려해보자.
- 아니면 동전 던지기로 정하던지....
    > 스텁은 질문하고 Mock 은 행동한다.

#### 3.3.2 준비, 시작, 단언
- given, when, then 구역을 구분하여 직관적으로 표현한다.

#### 3.3.3 구현이 아니라 동작 확인
- Mock 객체 사용시 검증 목적과 관련없는 사소한 것도 테스트 실패할 경우 손이 너무 많이간다.
    - 검사하려는 동작 외 부수적인 구현은 검증 대상에서 제외한다.
- 의도를 명확히 전달하도록 작성한다.

#### 3.3.5 종속 객체 주입
- 종속으로 인해 다른 객체와 교체하기 어려워진다면 그 객체를 사용하는 곳과 생성하는 곳을 달리하는게 좋다.
- 종속 객체를 분리했다면 주입을 통해 종속 객체를 외부에서 가져와야한다. (생성자 주입 추천!)
