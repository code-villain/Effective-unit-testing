# 07 테스트 가능 설계

테스트 용이성에 대해 알아 보자

## 7.1 테스트 가능 설계란?

테스트 가능설계는 테스트 코드에서

- 클래스를 생성하고
- 구현 일부를 대체하고
- 다른 시나리오를 시뮬레이션 하고
- 원하는 실행 경로를 선택

하는 등의 작업을 쉽게 해준다

테스트 용이성이란?

테스트 할 수 있는 소프트 웨어냐? 아니냐? 를 설명하는게 아니라 얼마나 쉽게 테스트 하느냐를 평가하는 용어다

### 7.1.1 모듈러 설계

제품의 전체 기능을 뚜렷한 역할로 나누고 그 역할 각각을 독립된 구성요소에 맡기면 유연한 설계를 만들게 된다

자신의 역할 완수에 필요한 모든 것을 갖춘 독립 모듈을 조합하여 전체 설계를 완성하려면 다양한 모듈 간 연결 인터페이스가 필요하다

- 모듈러 설계는 모듈 간 종속성을 최소화한다

특정 기능을 담당하는 독립된 기능 요소로 나누어 구성하는 모듈러 설계의 큰 특징

모듈 방식으로 설계된 구조에서는 기존 모듈을 교체하면 기능이 변하고 새로운 모듈을 추가하면 없던 기능이 생긴다

모듈 방식으로 설계하면

- 테스트 하기 좋은 코드가 만들어진다.
- 대역을 사용하기 쉬워진다

### 7.1.2 SOLID 설계 원칙

단일 책임 원칙

- 클래스를 수정해야 하는 이유는 오직 하나여야 한다
- 클래스는 작고 한 가지 역할에만 충실하고 응집력이 높아햐 한다
- 메서드를 수정해야 하는 이유 역시 하나뿐이어야 한다

개방 폐쇄 원칙

- 클래스는 확장에 개방적이고 수정에는 폐쇄적 이어야 한다
- 코드 수정 없이도 클래스의 기능을 변경할 수 있도록 해야 한다
- 자신의 역할 일부를 다른 객체에 위임하도록 만들어진 클래스라면
그 기능을 테스트 더블로 교체하여 원하는 시나리오를 시뮬레이션 할 수 있다.

리스코프 치환 원칙

- 상위 클래스는 하위 클래스로 대체될 수 있어야 한다
- 상위 클래스의 인스턴스를 사용하는 코드에 하위 클래스의 인스턴스를 넣어도 동작에 문제가 없어야 한다
- 계약 테스트 : 인터페이스에 정의된 기능을 제공하겠다는 계약
- 계약 테스트가 가능해진다. 인터페이스에 정의된 기능을 제공하겠다는 계약을 구현체가 제대로 지키는지 검증할 수 있다.

인터페이스 분리 원칙

- 하나의 범용 인터페이스 보다 쓰임새별로 최적화한 인터페이스 여러개가 낫다
- 인터페이스는 작고 한가지 목적에 충실하도록 만들어야 한다
- 인터페이스가 작으면 테스트 더블도 쉽게 작성할 수 있어 테스트 용이성이 높아진다

의존 관계 역전 원칙

- 코드는 구현체가 아닌 추상 개념에 종속되어야 한다
- 협력 객체를 직접 생성하지 말고 인터페이스로 건네받아야 한다. 협력 객체를 외부에서 넘겨 받아야 한다
- 종속 객체 주입 방식을 적용하면 협력 객체를 마음대로 교체할 수 있다.

### 7.1.3 맥락을 고려한 모듈러 설계

모듈을 조합하여 시스템을 구성할 수 있게 하는 것은 중요하다.

하지만 이 시스템이 언젠가 다른 시스템의 일부가 될 수 있다는 것을 고려하여 설계해야 한다

- 즉 확장을 고려한 설계가 필요하다는 말이다

### 7.1.4 모듈러 설계를 위한 시운전

제품 코드보다 테스트를 먼저 작성하게 되면 API의 사용자인 고객의 관점에서 바라보게 된다

TDD 실천자

- 수시로 리팩토링해서 큰 메서드를 작게 나누게 된다
- 적절한 추상화 수준을 고려한다
- 중복을 끊임없이 찾아낸다

## 7.2 테스트 불가 원인
- 원하는 것에 접근하지 못할 때
- 대상 코드의 특정 부분을 마음대로 교체할 수 없을 때

### 7.2.1 클래스 생성 불가

- 테스트 할 때 객체 생성, 협력 객체 주입에 문제가 없어야 한다???

### 7.2.2 메서드 호출 불가

- private 메서드를 호출해야 할 때
- Map 객체가 무엇을 담고 있는지 알 수가 없을 때
- 테스트를 포기하거나 ㅜㅜ , 리플렉션 API 를 써서 접근 제한자를 우회해야 한다

### 7.2.3 결과 확인 불가

- 아무것도 반환하지 않는 void 메서드나 다른 협력 객체와 상호작용하는 메서드라면 복잡해진다
- 협력객체가 심하게? 결합해버려 테스트 더블로 대체하지 못하게 될 때?

### 7.2.4 협력 객체 대체 불가

- 객체 생성 로직이 제품 코드에 하드 코딩 되어 있으면 대체 하기 힘들어진다
- 메서드 연쇄 호출 구조는 협력 객체로 대체하기 힘들다
- 데미테르 법칙...?을 고려하자

### 7.2.5 메서드 오버라이딩 불가

- 테스트 더블로 협력 객체를 대체할 수 있게 한 구조는 단위테스트 작성에 도움이 된다

## 7.3 테스트 가능 설계를 위한 지침

### 7.3.1 복잡한 private 메서드를 피하라