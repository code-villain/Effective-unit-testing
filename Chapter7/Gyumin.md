# Chapter7 테스트 가능 설계

## 테스트 가능 설계란?

---
## 테스트 불가 원인

### 클래스 생성 불가
- 테스트 대상에 넘겨줘야 할 **협력 객체를 만들 수 없는** 경우
  - 접근 제한자를 너무 보수적으로 설정
  - 정적 초기화 블록을 잘못 사용. 해당 클래스를 사용하는 클래스에서 다음의 문제가 발생할 수 있다.
    - static 블록 내에서 뭔가 exception이 발생할 가능성.
    - 해당 클래스가 의존하고 있는 종속성에 대한 초기화가 static 블록에서 하드코딩된 값으로 이루어지므로, 내가 제어할 수 있는 부분이 별로 없다.

### 메서드 호출 불가
- **테스트에서 private 메서드를 호출**하고 싶을 때
  - 상황 자체가 잘못된 것이다. 테스트에서 호출할 일이 있다는 것은 애초에 public으로 선언했어야 했다는 뜻이다.
- **어떤 인자를 넣어야 할지** 알쏭달쏭한 경우
  - ex) 인자가 Map인 경우. map의 key/value에 어떤 값을 담아야 할지가 직관적이지 않고, 관련 코드나 문서를 찾아보느라 흐름이 끊기게 만든다.

### 결과 확인 불가
- 원하는 메서드를 호출할 수는 있지만 **결과가 올바른지는 확인할 수 없는** 경우
- 확인해야 할 상호작용을 가로챌 방법이 없을 때
  - 협력 객체가 테스트할 메서드 안에 꽁꽁 묶여 있어서 **테스트 더블로 대체하지 못할 때**
  - 즉 테스트 하고자 하는 메서드(제품 코드)의 내부에서 **협력 객체의 생성 로직이 하드코딩**되어 있는 경우

### 협력 객체 대체 불가
- **협력 객체를 생성하는 로직이 제품 코드에 하드코딩**되어 있는 경우
- 메서드 체이닝으로 인해 **협력 객체의 대체 과정이 쓸데없이 복잡**한 경우

### 메서드 오버라이딩 불가
- 협력 객체 전부를 대체하기보다는, **대상 객체의 일부 코드만 변경하고 싶을 때**가 있다.
  - 예를 들어 검증하려는 메서드에서 사용하는 특정 메서드를 오버라이딩함으로써, 테스트 대상 객체의 일부를 변경하고자 한다고 가정해보자. 그러나 그 메서드가 `private static final Collaborator getCollaborator()`와 같다면, **오버라이딩이 불가능**하다.