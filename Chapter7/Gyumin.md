# Chapter7 테스트 가능 설계

## 테스트 가능 설계란?

---
## 테스트 불가 원인

### 클래스 생성 불가
- 테스트 대상에 넘겨줘야 할 **협력 객체를 만들 수 없는** 경우
  - 접근 제한자를 너무 보수적으로 설정
  - 정적 초기화 블록을 잘못 사용. 해당 클래스를 사용하는 클래스에서 다음의 문제가 발생할 수 있다.
    - static 블록 내에서 뭔가 exception이 발생할 가능성.
    - 해당 클래스가 의존하고 있는 종속성에 대한 초기화가 static 블록에서 하드코딩된 값으로 이루어지므로, 내가 제어할 수 있는 부분이 별로 없다.

### 메서드 호출 불가
- **테스트에서 private 메서드를 호출**하고 싶을 때
  - 상황 자체가 잘못된 것이다. 테스트에서 호출할 일이 있다는 것은 애초에 public으로 선언했어야 했다는 뜻이다.
- **어떤 인자를 넣어야 할지** 알쏭달쏭한 경우
  - ex) 인자가 Map인 경우. map의 key/value에 어떤 값을 담아야 할지가 직관적이지 않고, 관련 코드나 문서를 찾아보느라 흐름이 끊기게 만든다.

### 결과 확인 불가
- 원하는 메서드를 호출할 수는 있지만 **결과가 올바른지는 확인할 수 없는** 경우
- 확인해야 할 상호작용을 가로챌 방법이 없을 때
  - 협력 객체가 테스트할 메서드 안에 꽁꽁 묶여 있어서 **테스트 더블로 대체하지 못할 때**
  - 즉 테스트 하고자 하는 메서드(제품 코드)의 내부에서 **협력 객체의 생성 로직이 하드코딩**되어 있는 경우

### 협력 객체 대체 불가
- **협력 객체를 생성하는 로직이 제품 코드에 하드코딩**되어 있는 경우
- 메서드 체이닝으로 인해 **협력 객체의 대체 과정이 쓸데없이 복잡**한 경우

### 메서드 오버라이딩 불가
- 협력 객체 전부를 대체하기보다는, **대상 객체의 일부 코드만 변경하고 싶을 때**가 있다.
  - 예를 들어 검증하려는 메서드에서 사용하는 특정 메서드를 오버라이딩함으로써, 테스트 대상 객체의 일부를 변경하고자 한다고 가정해보자. 그러나 그 메서드가 `private static final Collaborator getCollaborator()`와 같다면, **오버라이딩이 불가능**하다.

---
## 테스트 가능 설계(Testable Design)을 위한 지침

### 복잡한 private 메서드를 피하라
- **private 메서드는 '직접' 테스트할 필요가 없도록** 만들어야 한다.
  - **public 메서드의 가독성을 높이기 위한 유틸리티로만 사용**하도록 한다.
- private 메서드에 대한 테스트를 만들고 싶어진다면, 해당 로직을 새로운 객체의 public 메서드로 공개하자.

### final 메서드를 피하라
- final 메서드가 필요한 경우는 많지 않다.
- final 메서드는 오버라이딩이 불가능하다.
  - 오버라이딩이 불가능한 메서드는 '테스트 불가 원인' 중 하나다.

### 정적 메서드를 피하라
- 정적(static) 메서드와 인스턴스 메서드를 각각 언제 써야 할까?
  - (단위 테스트에서) **언젠가 stub으로 바꿔야 할 것 같은 메서드는 정적 메서드로 만들지 말자**
    - stub으로 교체하기 어려워지기 때문이다.
- 만약 이미 존재하는 정적 메서드를 stub으로 교체하고 싶다면?
  - 해당 기능을 인스턴스 메서드로 제공하는 별도의 객체를 만든다.
  - 그래야 stub으로 교체하기가 쉬워진다.

### new는 신중하게 사용하라
- 객체를 `new` 하는 것은 정확한 구현이 그것이라고 못 박는 행위다(하드코딩).
- **메서드 본문에서는 앞으로 테스트 더블로 대체할 가능성이 없는 객체만 직접 생성**해야 한다.
- 테스트 하려는 메서드 안에서 사용하는 특정 객체를 다른 구현체로 교체해서 테스트해야 한다면,
  - 해당 객체는 메서드 안에서 생성하는게 아니라 **외부에서 넘겨받게끔** 해야 한다.
    - 테스트 더블을 만들어서 넣어주면 되기 때문이다.

### 생성자에서는 로직 구현을 피하라
- **테스트에 영향을 미칠만한 로직은 생성자에 넣으면 안된다**.
  - 상속이 끼어있다면 더욱 그렇다. 상위 클래스의 생성자까지 호출되어야 하기 때문이다.
- 거대한 생성자는 생성자 내부에서 하는 일들의 일부를 대체하기 까다롭게 만든다.
- 생성자 내부의 복잡한 로직을 **필요에 따라 메서드로 추출**하되, **접근 제어자를 protected로** 하면 **하위 클래스에서 해당 메서드를 오버라이딩**할 수 있으므로 대체가 가능하다.
- 생성자에는 단위 테스트에서 교체할 가능성이 있는 코드를 절대 넣어서는 안된다.
  - **교체할 가능성이 있는 로직은 메서드로 추출**하거나, **외부에서 객체를 전달 받는 형태**로 수정해야 한다. 그래야 테스트에서 원하는 대로 대체할 수 있다.

### 싱글톤을 피하라
- 싱글톤 패턴은 **테스트가 자신에게 필요한 대용품을 만들 수 없게 가로막는** 경우가 있다.
- 싱글톤 객체는 한 번 초기화되면 절대로 교체할 수 없다.
  - 테스트에서 해당 객체를 다른 객체로 변경하려면 리플렉션 API를 사용하거나 별도의 setter 메서드를 만들어야 하는 불편함이 있다.
- 꼭 정적 싱글톤 메서드를 사용해야만 한다면, **인터페이스를 반환하도록 하면 테스트에서 원하는 대로 조작하기가 훨씬 수월하다**.

### 상속보다는 컴포지션을 사용하라
- 재사용 목적으로 상속을 이용하는 것은 좋지 않다!
  - 물론 상속으로 코드를 재사용할 수는 있지만, 한 번 **상속을 사용하면 클래스 계층 구조는 변경하기 어려워지므로 테스트 용이성을 떨어뜨린다**.
> 상속의 용도는 ~~재사용~~이 아니라 **다형성**이다.
- 다형성을 활용하기 위해 상속을 사용하는 것은 전혀 문제가 없다.
  - 다만 **기능을 재활용하기 위한 목적이라면 컴포지션(조합)이 낫다**.

### 외부 라이브러리를 감싸라

### 서비스 호출을 피하라
