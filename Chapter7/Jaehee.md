# Chapter 7 테스트 가능 설계  

## 1. 테스트 가능 설계란?  
- 테스트 가능 설계의 가장 큰 의의: 코드를 더 잘 테스트할 수 있도록 해준다    
- 구체적으로는 테스트 코드에서 클래스를 생성하고, 구현 일부를 대체하고, 다른 시나리오를 시뮬레이션하고, 원하는 실행 경로를 선택하는 등의 작업을 쉽게 할 수 있도록 해준다.  
- **테스트 용이성** : 소프트웨어를 **얼마나 쉽게** 테스트할 수 있느냐를 평가하는 용어  

### 1) 모듈러 설계  
- 제품의 전체 기능을 뚜렷한 역할로 나누고 그 역할 각각을 독립된 모듈에 맡기면 유연한 설계가 된다.  
- 각 모듈을 연결하는 인터페이스가 유연성을 높여주는 원천  
- 향후 기능을 변경할 때 영향을 받는 코드가 일부 모듈에만 국한되게 한다.  
- 모듈 간 종석성이 낮고 역할 수행에 필요한 정보를 각자가 가지게 한다.  

### 2) SOLID 설계 원칙  
- 단일 책임 원칙 : 클래스를 수정해야 하는 이유는 오직 하나뿐이어야 한다.  
- 개방 폐쇄 원칙 : 클래스는 확장을 위해서는 개방적이되 수정에 대해서는 폐쇄적이어야 한다.  (코드 수정 없이도 클래스의 기능을 변경할 수 있도록 하자)
- 리스코프 치환 원칙 : 상위 클래스는 하위 클래스로 대체될 수 있어야 한다.  
- 인터페이스 분리 원칙 : 인터페이스는 작고 한 가지 목적에 충실하도록 만들어야 한다.  
- 의존 관계 역전 원칙 : 코드는 구현체가 아닌 추상 개념에 종속되어야 한다.  

### 3) 맥락을 고려한 모듈러 설계  
- 해법이 전체 시스템과 잘 어울리는지 >> 주어진 문제에 대한 해법  
- 당장 사용하려는 방식은 물론 향후의 확장까지 고려해야 좋은 설계  

### 4) 모듈러 설계를 위한 시운전  
- 테스트를 먼저 작성하면 API의 사용자인 고객의 관점에서 바라보게 된다.  

## 2. 테스트 불가 원인  
### 1) 클래스 생성 불가  
- 접근제어자를 보수적으로 설정한 경우  
- 정적 초기화 블록을 잘못 사용해서 생성자만으로 클래스 생성을 온전히 제어할 수 없는 경우  

### 2) 메서드 호출 불가  
- 접근제어자를 보수적으로 설정한 경우  

### 3) 결과 확인 불가  
- void 메서드거나 다른 협력 객체와 상호작용하는 메서드인 경우  

### 4) 협력 객체 대체 불가  
- 협력 객체를 하드코딩해 놓은 경우

### 5) 메서드 오버라이딩 불가  
- final, private, static 메서드인 경우  
- 리플렉션과 바이트 코드 조작으로 가능하지만 좋지 않은 방법  

## 3. 테스트 가능 설계를 위한 지침  
### 1) 복잡한 private 메서드를 피하라  
- private 메서드를 직접 테스트하지 말자  
- private 메서드 사용법이 명확하지 않고 테스트가 필요하다면 코드를 리팩토링하는 것이 필요  

### 2) final 메서드를 피하라  
- 메서드를 final로 만드는 가장 큰 목적: 하위 클래스에서 오버라이딩 방지  
- final을 선언해서 얻는 이득 vs final이 테스트를 방해하는 부분  

### 3) 정적 메서드를 피하라  
- 정적 메서드 대부분은 클래스 인스턴스와 관련이 없어 소속을 결정하기 어려운 경우  
### 4) new는 신중하게 사용하라 
- 하드코딩의 가장 흔한 형태가 바로 new  
- 그것이 협력 객체고 다른 구현체로 바꿔가며 테스트해야 할 것 같다면 메서드 안에서 생성하지 말고 외부에서 넘겨받게 만들자  

### 5) 생성자에서는 로직 구현을 피하라  
- 테스트에 영향을 미칠만한 로직은 생성자에 넣어선 안된다.
- 일반 메서드로 추출하거나 외부에서 객체 형태로 입력받게끔 수정  

### 6) 싱글톤을 피하라  
- 싱글톤:  클래스의 인스턴스가 단 하나만 만들어진다는 것을 보장하고 어디에서나 접근할 수 있도록 한 패턴  (생성자를 private으로 선언하고 getInstance() 메서드에서만 접근할 수 있도록 제한)  
- 테스트에서 필요한 대용품을 만들 수 없게 가로막는다.  
- 소문자 singleton을 이용해서 장치적 보장 대신 팀원 간 합의로 사용하는 것을 추천  

### 7) 상속보다는 컴포지션을 사용하라  
- 상속의 용도: 코드 재사용이 아니라 다형성  
- 상속으로 만들어진 클래스 계층 구조는 변경할 수 없으므로 테스트 용이성을 떨어뜨림  
- 기능 재활용을 위해서는 컴포지션 방식이 낫다.  

### 8) 외부 라이브러리를 감싸라  
- 상속하려는 코드에 대한 제어권이 거의 없기 때문에 교체, 테스트가 쉬운 인터페이스를 만들어서 사용하자  

### 9) 서비스 호출을 피하라  
- 생성자의 입력 인자를 통해 명확히 드러났어야 할 종속성을 숨긴 경우  


