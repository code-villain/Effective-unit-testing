# Chapter2 좋은 테스트란?

(_아래의 목록은 저자 개인의 주관이 들어가 있을 수 있고, 또 테스트 품질에 영향을 주는 요소는 끝도 없이 많기 때문에 완벽한 기준은 아니라고 한다_.)

---
## 테스트 코드의 가독성과 유지보수성
### 읽기 쉬운 코드가 유지보수도 쉽다
- 가독성과 결함 밀도는 반비례한다.
  - 즉, 읽기 어려운 코드일수록 결함 수가 많다.
- 코드의 가독성이 나쁨 → 코드를 검증하기도 어렵고, 결과적으로 테스트를 조금만 작성하게 됨 → 테스트를 고려하지 않는 제품 코드가 만들어짐 → 나쁜 테스트를 작성하게 됨

---
## 코드는 적절히 구조화되어 있는가?
### 구조화가 잘 되어 있다면 이해하기 쉽다
![image](https://user-images.githubusercontent.com/26949964/71793098-a7f3b280-307e-11ea-9954-9f2eb3ec8bc7.png)
- 읽기 쉽고, 찾기 쉽고, 이해하기 쉽도록 한 가지 기능에 충실한 테스트가 필요하다. 그렇게 되면,
  - 현재 작업과 관련된 테스트 클래스를 찾을 수 있다.
  - 그 클래스에서 적절한 테스트 메서드를 고를 수 있다.
  - 그 메서드에서 사용하는 객체의 생명주기를 이해할 수 있다.
- 프로덕션 코드의 구현 상태를 정확히 이해하고자 할 때, 코드 동작 방식을 구체적으로 보여주는 테스트 코드를 정독하면 도움이 된다.
  - 다만 테스트 코드가 제대로 구조화되어 있지 않다면, 테스트 코드 어디를 봐야 하는지 찾아내기 어렵다는 것이 함정이다.

---
## 테스트가 무엇을 검사하는가?
### 엉뚱한 걸 검사하는 건 좋지 않다
- 테스트 **이름**을 보면 그 테스트가 검사하는 내용을 알 수 있어야 한다.
  - 그래야만 테스트를 신뢰할 수 있다.
  - 테스트 이름과 전혀 관련 없는 것을 테스트하지 않도록 한다.

---
## 테스트는 안정적이고 반복 가능한가?
### 독립적인 테스트는 혼자서도 잘 실행된다
- '격리'와 '독립성'이 중요하다(특히 아키텍처의 **경계** 부분이 중요).
  - 그렇지 않다면 테스트를 실행하고 관리하기가 훨씬 어렵기 때문이다(불안정적이며, 반복적으로 테스트하기 어렵다는 뜻).
  - 종속성은 '우리가 제어할 수 없기' 때문에 위험하다. 불규칙한 테스트를 유발한다.
- 테스트를 서로 종속되지 않게 하라
  - (일반적으로) 한 클래스의 테스트가 다른 클래스의 테스트 실행 여부나 그 결과에 의존하면 안된다.
  - 이는 같은 클래스 내에서도 마찬가지다.
  - 테스트가 특정 순서로 실행될 거라는 가정은 금물이다(JUnit은 테스트 메서드의 실행 순서를 보장하지 않는다!).
- 다음의 것들을 검사할 때는 각별한 주의가 필요하다. 이들과의 종속성은 가능하다면 피하도록 하고, 아니면 작고 격리된 단위로 구분해서 다른 테스트를 보호해야 한다.
  - 시간(Time)
  - 임의성(Randomness)
  - 동시성(Concurrency)
  - 인프라(Infrastructure)
  - 기존 데이터(Pre-existing Data)
  - 영속성(Persistency)
  - 네트워킹(Networking)
- 실전에서 해야할 일
  - 테스트 더블로 서드파티 라이브러리와의 종속성을 제거한다. 손수 만든 adapter로 적절히 감싸줌으로써 성가신 부분이 adapter 안으로 감춰진다.
  - 테스트에 필요한 자원을 테스트 코드와 같은 위치, 즉 같은 패키지에 둔다.
  - 테스트가 필요로 하는 자원을 테스트 코드가 직접 만들도록 한다.
  - 테스트가 필요로 하는 문맥을 테스트가 직접 설정하게 한다. 절대 다른 테스트에 의존하지 않는다.
  - 영속성이 필요한 통합 테스트라면 in-memory 데이터베이스를 활용한다. 테스트를 위한 깨끗한 데이터를 훨씬 간단하게 준비할 수 있고 초기화 시간도 상당히 단축된다.
  - thread를 사용하는 코드는 동기식과 비동기식을 구분 짓는다. 평범한 동기식 코드로 작성된 로직들은 쉽게 테스트할 수 있게 된다. 골치 아픈 동시성 문제는 소규모의 전문 테스트 그룹에 맡긴다.

### 믿음직한 테스트라야 기댈 수 있다
- 절대 실패하지 않거나 항상 실패하는 테스트는 있으나 마나다.
![image](https://user-images.githubusercontent.com/26949964/71794101-4d108a00-3083-11ea-9177-628b904fd45a.png)
- 테스트를 믿고 의지하려면 **반복할 수 있게** 만들어야 한다.
  - 10번 실행하면 10번 모두 반드시 같은 결과가 나와야 한다.
- 애플리케이션이 비동기적 요소나 현재 시각에 종속된 코드를 포함한다면, 그 부분을 **인터페이스로 감싸 격리**해야 한다.
  - 그러면 **테스트 더블**로 대체할 수 있어 **반복 가능한 테스트**를 만들 수 있다.

---
## 테스트가 테스트 더블을 잘 활용하는가?
### 테스트에도 도구가 쓰인다
- 테스트 더블
  - stub, fake 객체, mock 객체 등을 통칭하는 개념
  - **테스트를 위해 실제 구현체와 교체할 수 있는 객체**
- 테스트 더블의 효과
  - 원래의 로직을 간소화된 코드로 대체하여 테스트 속도를 개선한다.
  - 만들어내기 어려운 특수한 상황을 시뮬레이션한다.
  - 대상 객체의 내부 상태나 동작 등 테스트가 접근할 수 없던 정보를 얻어낸다.
  - "**테스트할 수 있는 범위를 넓혀준다**".